name: CI/CD Deployment Pipeline

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'Optional version bump: major | minor | patch（留空不變）'
        required: false
        default: ''
  push:
    branches: [ master ]   # 若預設分支是 main，改成 [ main ]

permissions:
  contents: write

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  # === Step 1：多版本測試矩陣（Node 18 / 20）===
  Test:
    name: Lint & Test (matrix)
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install
        if: ${{ hashFiles('**/package.json') != '' }}
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Lint (if present)
        run: npm run lint --if-present

      - name: Test (if present)
        run: npm test --if-present

  # === Build：計算版本/標籤 → 產物 → 上傳 ===
  Build:
    name: Build
    needs: [Test]
    runs-on: ubuntu-latest
    # 將版本/標籤透過 job outputs 提供給後續部署使用
    outputs:
      version:      ${{ steps.meta.outputs.version }}
      staging_tag:  ${{ steps.meta.outputs.staging_tag }}
      prod_tag:     ${{ steps.meta.outputs.prod_tag }}
      dev_tag:      ${{ steps.meta.outputs.dev_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node (only when Node project)
        if: ${{ hashFiles('**/package.json') != '' }}
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # === Step 2：計算版本與標籤（關鍵步驟）===
      - name: Compute Version & Tags (O-level)
        id: meta
        shell: bash
        run: |
          # 讀 package.json version；若無則 fallback 1.0.0
          if [ -f package.json ]; then
            BASE_VERSION=$(node -p "require('./package.json').version || '1.0.0'")
          else
            BASE_VERSION="1.0.0"
          fi

          # 支援 workflow_dispatch bump（major/minor/patch），留空則不變
          BUMP="${{ github.event.inputs.bump }}"
          if [ -n "$BUMP" ]; then
            IFS='.' read -r MA MI PA <<< "$(echo "$BASE_VERSION" | sed 's/-.*//')"
            case "$BUMP" in
              major) MA=$((MA+1)); MI=0; PA=0 ;;
              minor) MI=$((MI+1)); PA=0 ;;
              patch|*) PA=$((PA+1)) ;;
            esac
            BASE_VERSION="${MA}.${MI}.${PA}"
          fi

          RUN_NO="${GITHUB_RUN_NUMBER}"

          STAGING_TAG="staging-v${BASE_VERSION}-rc.${RUN_NO}"
          PROD_TAG="prod-v${BASE_VERSION}"
          DEV_TAG="dev-v${BASE_VERSION}-alpha.${RUN_NO}"

          echo "version=$BASE_VERSION"    >> "$GITHUB_OUTPUT"
          echo "staging_tag=$STAGING_TAG" >> "$GITHUB_OUTPUT"
          echo "prod_tag=$PROD_TAG"       >> "$GITHUB_OUTPUT"
          echo "dev_tag=$DEV_TAG"         >> "$GITHUB_OUTPUT"

      # 顯示輸出到 Logs 與 Step Summary（方便你看到）
      - name: Show computed version & tags
        run: |
          echo "version=${{ steps.meta.outputs.version }}"
          echo "staging_tag=${{ steps.meta.outputs.staging_tag }}"
          echo "prod_tag=${{ steps.meta.outputs.prod_tag }}"
          echo "dev_tag=${{ steps.meta.outputs.dev_tag }}"
          {
            echo "## Build metadata"
            echo ""
            echo "- version: \`${{ steps.meta.outputs.version }}\`"
            echo "- staging_tag: \`${{ steps.meta.outputs.staging_tag }}\`"
            echo "- prod_tag: \`${{ steps.meta.outputs.prod_tag }}\`"
            echo "- dev_tag: \`${{ steps.meta.outputs.dev_tag }}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Setup Bun (for bun-based builds)
        if: ${{ hashFiles('**/package.json') != '' }}
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 'latest'

      - name: Install deps & build (bun/npm)
        if: ${{ hashFiles('**/package.json') != '' }}
        run: |
          set -e
          bun install || true
          if [ -f package-lock.json ]; then npm ci || true; else npm install || true; fi
          npm run build --if-present || true

      - name: Archive workspace
        run: zip -r build.zip . -x ".git/*" "node_modules/*"

      - uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: build.zip
          retention-days: 7

  # === （可選）Dev 用動態標籤 ===
  DeployDev:
    name: Deploy to Dev
    needs: [Build]
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/master' }}   # 若改 main 也改這條
    environment:
      name: Development
      url: ${{ format('https://github.com/{0}/releases', github.repository) }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: build-artifact

      - name: Print tag being released (Dev)
        run: echo "TAG=${{ needs.Build.outputs.dev_tag }}"

      - name: Release Dev Build (dynamic tag)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ needs.Build.outputs.dev_tag }}
          NOTE: ${{ vars.RELEASE_NOTE }}
        run: |
          set -e
          gh auth status || gh auth login --with-token <<< "$GH_TOKEN"
          if gh release view "$TAG" --repo "$REPO" >/dev/null 2>&1; then
            echo "⚠️ $TAG already exists. Skipping."
          else
            gh release create "$TAG" build.zip --prerelease --generate-notes --notes "$NOTE" --repo "$REPO"
          fi

  # === Staging 用動態標籤（同一份 artifact）===
  DeployStaging:
    name: Deploy to Staging
    needs: [Build]
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/master' }}
    environment:
      name: Staging
      url: ${{ format('https://github.com/{0}/releases', github.repository) }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: build-artifact

      - name: Print tag being released (Staging)
        run: echo "TAG=${{ needs.Build.outputs.staging_tag }}"

      - name: Release Staging Build (dynamic tag + auto notes)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ needs.Build.outputs.staging_tag }}
          NOTE: ${{ vars.RELEASE_NOTE }}
        run: |
          set -e
          gh auth status || gh auth login --with-token <<< "$GH_TOKEN"
          if gh release view "$TAG" --repo "$REPO" >/dev/null 2>&1; then
            echo "⚠️ $TAG already exists. Skipping."
          else
            if [ -z "$NOTE" ]; then
              gh release create "$TAG" build.zip --generate-notes --repo "$REPO"
            else
              gh release create "$TAG" build.zip --generate-notes --notes "$NOTE" --repo "$REPO"
            fi
          fi

  # === Production：需要 Staging 成功 + 受保護環境審核 ===
  DeployProd:
    name: Deploy to Production
    needs: [DeployStaging]
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/master' }}
    environment:
      name: Production       # 必須和 Settings → Environments 名稱一致，且設 Required reviewers
      url: ${{ format('https://github.com/{0}/releases', github.repository) }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: build-artifact

      - name: Print tag being released (Prod)
        run: echo "TAG=${{ needs.Build.outputs.prod_tag }}"

      - name: Release Production Build (dynamic tag + auto notes)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ needs.Build.outputs.prod_tag }}
          NOTE: ${{ vars.RELEASE_NOTE }}
        run: |
          set -e
          gh auth status || gh auth login --with-token <<< "$GH_TOKEN"
          if gh release view "$TAG" --repo "$REPO" >/dev/null 2>&1; then
            echo "⚠️ $TAG already exists. Skipping."
          else
            if [ -z "$NOTE" ]; then
              gh release create "$TAG" build.zip --generate-notes --repo "$REPO"
            else
              gh release create "$TAG" build.zip --generate-notes --notes "$NOTE" --repo "$REPO"
            fi
          fi

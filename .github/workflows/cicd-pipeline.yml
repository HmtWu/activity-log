name: CI/CD Deployment Pipeline

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'Optional version bump: major | minor | patch（留空則自動偵測）'
        required: false
        default: ''
  push: 
    branches: [ master ]   # 若預設分支是 main，改成 [ main ]

permissions:
  contents: write

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  # === Step 1：多版本測試矩陣（Node 18 / 20）===
  Test:
    name: Lint & Test (matrix)
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install
        if: ${{ hashFiles('**/package.json') != '' }}
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi
      - name: Lint (if present)
        run: npm run lint --if-present

      - name: Test (if present)
        run: npm test --if-present

  # === Build：自動偵測版本升級 + 計算標籤 ===
  Build:
    name: Build
    needs: [Test]
    runs-on: ubuntu-latest
    outputs:
      version:      ${{ steps.meta.outputs.version }}
      staging_tag:  ${{ steps.meta.outputs.staging_tag }}
      prod_tag:     ${{ steps.meta.outputs.prod_tag }}
      dev_tag:      ${{ steps.meta.outputs.dev_tag }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        if: ${{ hashFiles('**/package.json') != '' }}
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # === 🔥 新增：自動偵測 bump 類型 ===
      - name: Detect bump type automatically
        id: detect
        shell: bash
        run: |
          MSG=$(git log -1 --pretty=%B | tr '[:upper:]' '[:lower:]')
          echo "最近一次 commit message: $MSG"
          if [[ "$MSG" == *"breaking change"* ]]; then
            TYPE="major"
          elif [[ "$MSG" == *"feat:"* ]]; then
            TYPE="minor"
          elif [[ "$MSG" == *"fix:"* ]]; then
            TYPE="patch"
          else
            TYPE=""
          fi
          echo "type=$TYPE" >> "$GITHUB_OUTPUT"
          echo "自動偵測結果：${TYPE:-無變更}"
      # === 計算版本與標籤 ===
      - name: Compute Version & Tags (O-level)
        id: meta
        shell: bash
        run: |
          # 從 package.json 抓目前版本
          if [ -f package.json ]; then
            BASE_VERSION=$(node -p "require('./package.json').version || '1.0.0'")
          else
            BASE_VERSION="1.0.0"
          fi
          # 若有手動輸入 bump，覆蓋自動偵測
          if [ -n "${{ github.event.inputs.bump }}" ]; then
            BUMP="${{ github.event.inputs.bump }}"
          else
            BUMP="${{ steps.detect.outputs.type }}"
          fi
          echo "最終使用的 bump 類型: ${BUMP:-無}"
          # 根據 bump 類型修改版本號
          if [ -n "$BUMP" ]; then
            IFS='.' read -r MA MI PA <<< "$(echo "$BASE_VERSION" | sed 's/-.*//')"
            case "$BUMP" in
              major) MA=$((MA+1)); MI=0; PA=0 ;;
              minor) MI=$((MI+1)); PA=0 ;;
              patch|*) PA=$((PA+1)) ;;
            esac
            BASE_VERSION="${MA}.${MI}.${PA}"
          fi
          RUN_NO="${GITHUB_RUN_NUMBER}"
          STAGING_TAG="staging-v${BASE_VERSION}-rc.${RUN_NO}"
          PROD_TAG="prod-v${BASE_VERSION}"
          DEV_TAG="dev-v${BASE_VERSION}-alpha.${RUN_NO}"
          echo "version=$BASE_VERSION"    >> "$GITHUB_OUTPUT"
          echo "staging_tag=$STAGING_TAG" >> "$GITHUB_OUTPUT"
          echo "prod_tag=$PROD_TAG"       >> "$GITHUB_OUTPUT"
          echo "dev_tag=$DEV_TAG"         >> "$GITHUB_OUTPUT"
      # === 顯示輸出結果 ===
      - name: Show computed version & tags
        run: |
          echo "version=${{ steps.meta.outputs.version }}"
          echo "staging_tag=${{ steps.meta.outputs.staging_tag }}"
          echo "prod_tag=${{ steps.meta.outputs.prod_tag }}"
          echo "dev_tag=${{ steps.meta.outputs.dev_tag }}"
          {
            echo "## Build metadata"
            echo ""
            echo "- version: \`${{ steps.meta.outputs.version }}\`"
            echo "- staging_tag: \`${{ steps.meta.outputs.staging_tag }}\`"
            echo "- prod_tag: \`${{ steps.meta.outputs.prod_tag }}\`"
            echo "- dev_tag: \`${{ steps.meta.outputs.dev_tag }}\`"
          } >> "$GITHUB_STEP_SUMMARY"
      - name: Install deps & build
        if: ${{ hashFiles('**/package.json') != '' }}
        run: |
          set -e
          npm ci || npm install
          npm run build --if-present || true
      - name: Archive workspace
        run: zip -r build.zip . -x ".git/*" "node_modules/*"

      - uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: build.zip
          retention-days: 7
  AutomatedTest:
    name: Run Automated Tests
    runs-on: ubuntu-latest
    needs: [Build]
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: build-artifact

      # ✨ 新增這段解壓縮
      - name: Unzip build artifact
        run: unzip build-artifact.zip -d .

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies for test
        run: npm install  # 改成這樣，不要用 npm ci

      - name: Run Automated Tests
        run: |
          echo "🧪 開始執行自動化測試..."
          npm test || (echo "❌ 測試失敗，停止後續部署。" && exit 1)
  # === 部署到 Dev ===
  DeployDev:
    name: Deploy to Dev
    needs: [AutomatedTest]
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/master' }}
    environment:
      name: dev   # ✅ 改成小寫以符合實際 environment 名稱
      url: ${{ format('https://github.com/{0}/releases', github.repository) }}

    steps:
      - uses: actions/download-artifact@v4
        with:
          name: build-artifact

      - name: Release Dev Build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ needs.Build.outputs.dev_tag }}
        run: |
          set -e
          echo "🔧 Releasing Dev build: $TAG"
          gh auth status || gh auth login --with-token <<< "$GH_TOKEN"
          gh release create "$TAG" build.zip --prerelease --generate-notes --repo "$REPO"

      # === 成功通知 Slack ===
      - name: Notify Slack (success)
        if: success()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          VERSION: ${{ needs.Build.outputs.version }}
          TAG: ${{ needs.Build.outputs.dev_tag }}
          REPO: ${{ github.repository }}
        run: |
          set -e
          MESSAGE="✅ *Dev Build Successful!*%0A• Version: \`${VERSION}\`%0A• Tag: \`${TAG}\`%0A• Repository: https://github.com/${REPO}/releases/tag/${TAG}"
          echo "Sending Slack notification..."
          curl -s -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"${MESSAGE}\"}" \
            "$SLACK_WEBHOOK_URL" || echo "⚠️ Slack notification failed (check webhook)"

      # === 失敗通知 Slack ===
      - name: Notify Slack (failure)
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          VERSION: ${{ needs.Build.outputs.version }}
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
        run: |
          set -e
          MESSAGE="❌ *Dev Build Failed!*%0A• Version: \`${VERSION}\`%0A• Check logs: https://github.com/${REPO}/actions/runs/${RUN_ID}"
          echo "Sending Slack failure notification..."
          curl -s -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"${MESSAGE}\"}" \
            "$SLACK_WEBHOOK_URL" || echo "⚠️ Slack notification failed (check webhook)"
  # === 部署到 Staging ===
  DeployStaging:
    name: Deploy to Staging
    needs: [AutomatedTest]
    runs-on: ubuntu-latest
    environment:
      name: Staging
      url: ${{ format('https://github.com/{0}/releases', github.repository) }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: build-artifact

      - name: Release Staging Build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ needs.Build.outputs.staging_tag }}
        run: |
          set -e
          gh auth status || gh auth login --with-token <<< "$GH_TOKEN"
          gh release create "$TAG" build.zip --prerelease --generate-notes --repo "$REPO"
      # === 成功通知 Slack ===
      - name: Notify Slack (success)
        if: success()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          VERSION: ${{ needs.Build.outputs.version }}
          TAG: ${{ needs.Build.outputs.prod_tag }}
        run: |
          MESSAGE="✅ *Staging Release Successful!*  
          • Version: \`${VERSION}\`  
          • Tag: \`${TAG}\`  
          • Repository: https://github.com/${GITHUB_REPOSITORY}/releases/tag/${TAG}"
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"${MESSAGE}\"}" \
            "$SLACK_WEBHOOK_URL"

      # === 失敗通知 Slack ===
      - name: Notify Slack (failure)
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          VERSION: ${{ needs.Build.outputs.version }}
        run: |
          MESSAGE="❌ *Staging Release Failed!*  
          • Version: \`${VERSION}\`  
          • Check logs: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"${MESSAGE}\"}" \
            "$SLACK_WEBHOOK_URL"
  DeployProd:
    name: Deploy to Production
    needs: [DeployStaging, AutomatedTest]   # ✅ 同時依賴 Build
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/master' }}
    environment:
      name: Production
      url: ${{ format('https://github.com/{0}/releases', github.repository) }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: build-artifact

      - name: Print tag being released (Prod)
        run: echo "TAG=${{ needs.Build.outputs.prod_tag }}"

      - name: Release Production Build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ needs.Build.outputs.prod_tag }}
        run: |
          set -e
          echo "Releasing $TAG ..."
          if [ -z "$TAG" ]; then
            echo "❌ TAG 未定義，請檢查 Build job 是否成功產出 tag"
            exit 1
          fi
          gh auth status || gh auth login --with-token <<< "$GH_TOKEN"

          # === 若 release 已存在，則先刪除舊的 ===
          if gh release view "$TAG" --repo "$REPO" &>/dev/null; then
            echo "⚠️ Release $TAG 已存在，將先刪除舊的 release 與 tag..."
            gh release delete "$TAG" --repo "$REPO" --yes || true
            git push origin ":refs/tags/$TAG" || true
          fi

          # === 重新建立 release ===
          echo "🚀 建立新的 Release: $TAG"
          gh release create "$TAG" build.zip --generate-notes --repo "$REPO"
      # === 成功通知 Slack ===
      - name: Notify Slack (success)
        if: success()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          VERSION: ${{ needs.Build.outputs.version }}
          TAG: ${{ needs.Build.outputs.prod_tag }}
        run: |
          MESSAGE="✅ *Production Release Successful!*  
          • Version: \`${VERSION}\`  
          • Tag: \`${TAG}\`  
          • Repository: https://github.com/${GITHUB_REPOSITORY}/releases/tag/${TAG}"
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"${MESSAGE}\"}" \
            "$SLACK_WEBHOOK_URL"

      # === 失敗通知 Slack ===
      - name: Notify Slack (failure)
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          VERSION: ${{ needs.Build.outputs.version }}
        run: |
          MESSAGE="❌ *Production Release Failed!*  
          • Version: \`${VERSION}\`  
          • Check logs: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"${MESSAGE}\"}" \
            "$SLACK_WEBHOOK_URL"
